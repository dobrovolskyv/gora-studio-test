export const js = [
    { title: 'В чем разница между let, const и var?', content: 'var имеет функциональную область видимости (или глобальную, если объявлена вне функции) и подвержен всплытию (hoisting).let имеет блочную область видимости и не подвержен всплытию (на самом деле всплывает, но нельзя использовать до объявления).const также имеет блочную область видимости, не подвержен всплытию и предназначен для переменных, которые не должны переназначаться.' },
    { title: 'Что такое контекст this в JavaScript? Как его можно определить или изменить?', content: 'Контекст this относится к объекту, с которым связана функция при ее вызове. Его значение может зависеть от способа вызова функции:В глобальном контексте (this вне любой функции) this обычно ссылается на глобальный объект (window в браузере, global в Node.js).При вызове метода объекта this ссылается на этот объект.При использовании call(), apply() или bind(), можно явно установить значение this.В стрелочных функциях this лексически наследуется из окружающей области видимости.' },
    { title: '', content: '' },
    { title: 'Что такое замыкание (closure) в JavaScript? Приведите пример использования.', content: 'Замыкание — это функция, которая запоминает свое лексическое окружение (переменные из внешней области видимости) даже после того, как внешняя функция завершила свое выполнение. Это позволяет внутренней функции иметь доступ к этим переменным.' },
    { title: 'Объясните разницу между == и === в JavaScript.', content: '== сравнивает значения после приведения типов (если типы разные), а === сравнивает как значения, так и типы данных без приведения. Рекомендуется использовать === для более предсказуемого поведения.' },
    { title: 'Что такое прототипное наследование в JavaScript?', content: 'Прототипное наследование — это механизм, с помощью которого объекты JavaScript могут наследовать свойства и методы от других объектов (прототипов). Каждый объект имеет ссылку на свой прототип (__proto__ или Object.getPrototypeOf() ).' },
    { title: 'Расскажите о Event Loop в JavaScript. Как он работает?', content: 'Event Loop — это механизм, который позволяет JavaScript быть неблокирующим. Он следит за Call Stack и Event Queue. Когда Call Stack пуст, Event Loop берет первую задачу из Event Queue и помещает ее в Call Stack для выполнения. Event Loop бесконечный цикл, который выполняет обработчик событий. Есть две основные очереди это микротаски и макротаски и выполняет синхронный код. К микротаскам относит промисы, мутешнобсервер .К макротаскам setTimeout , различные таймер, обработчики событий. Порядок такой, что вначале выполняется синхронный код, потом все микротаски, потом из очереди берется одна макротаска, выполняется. Потом идет проверка синхронного кода и микротасок и так по кругу ' },
    { title: 'Что такое промисы (Promises) в JavaScript? Как они решают проблему callback hell?', content: 'Промисы — это объекты, представляющие результат асинхронной операции (который может быть доступен сейчас, в будущем или никогда). Они имеют три состояния: pending, fulfilled и rejected. Промисы улучшают читаемость асинхронного кода по сравнению с вложенными колбэками, делая код более плоским и управляемым с помощью .then(), .catch() и async/await.' },
    { title: 'Что такое async/await? Как они работают?', content: 'async/await — это синтаксический сахар над промисами, который делает асинхронный код похожим на синхронный. async объявляет функцию асинхронной, а await приостанавливает выполнение функции до тех пор, пока промис не будет разрешен (resolved) или отклонен (rejected).' },
    { title: 'Объясните разницу между call, apply и bind в JavaScript. Когда какой метод лучше использовать?', content: 'Эти методы используются для вызова функции с определенным значением this.call() принимает аргументы через запятую.apply() принимает аргументы в виде массива.bind() создает новую функцию с зафиксированным значением this и, при необходимости, предопределенными аргументами, но не вызывает функцию немедленно.Используйте call или apply, когда нужно немедленно вызвать функцию с определенным контекстом и набором аргументов (массивом для apply). Используйте bind, когда нужно создать новую функцию с привязанным контекстом, которую можно будет вызвать позже.' },
    { title: 'Что такое Higher-Order Functions (функции высшего порядка) в JavaScript? ', content: 'Функция высшего порядка — это функция, которая принимает другую функцию в качестве аргумента или возвращает функцию в качестве результата. Примеры: map, filter, reduce.' },
    { title: 'Что такое Spread syntax (...) и Rest parameters (...) в JavaScript? В чем разница между ними?', content: 'Spread syntax: Позволяет расширять итерируемые объекты (например, массивы, строки, объекты) в местах, где ожидаются ноль или более аргументов (при вызове функции) или элементов (в массивах/объектах).Rest parameters: Позволяют функции принимать неопределенное количество аргументов в виде массива. Они появляются в определении функции.' },
    { title: 'Что такое деструктуризация (destructuring) в JavaScript? Приведите примеры для массивов и объектов.', content: 'Деструктуризация — это синтаксис, который позволяет извлекать значения из массивов или свойства из объектов и присваивать их отдельным переменным.' },
    { title: '', content: '' },
    { title: '', content: '' },
]

export const react = [
    { title: 'Что такое Virtual DOM в React? Зачем он нужен?', content: 'Virtual DOM — это легковесная копия реального DOM, которая хранится в памяти. Когда состояние компонента меняется, React сначала обновляет Virtual DOM, затем сравнивает его с предыдущей версией (процесс reconciliation) и применяет только необходимые изменения к реальному DOM, что повышает производительность.' },
    { title: 'Объясните разницу между контролируемыми и неконтролируемыми компонентами в React. Когда какой подход лучше использовать?', content: 'Контролируемые компоненты: Значение элемента формы хранится в состоянии React-компонента, и React контролирует изменения. Обработчики событий обновляют состояние, что, в свою очередь, обновляет значение элемента. Лучше подходят, когда нужно программно контролировать ввод.Неконтролируемые компоненты: Значение элемента формы хранится непосредственно в DOM. Для доступа к значению используется ref. Удобны для простых форм, где не требуется сложная логика обработки ввода.' },
    { title: 'Что такое хуки (Hooks) в React? Какие основные хуки вы знаете?', content: 'Хуки — это функции, которые позволяют использовать состояние и другие возможности React в функциональных компонентах. Основные хуки: useState, useEffect, useContext, useRef, useMemo, useCallback.' },
    { title: 'Расскажите о useEffect хуке. Как он работает и для чего используется?', content: 'useEffect используется для выполнения побочных эффектов в функциональных компонентах (например, подписка на события, запросы к API, таймеры). Он принимает два аргумента: функцию с эффектом и необязательный массив зависимостей. Эффект выполняется после каждого рендера (или при изменении зависимостей).' },
    { title: 'Что такое пропсы (props) и как они используются для передачи данных между компонентами?', content: 'Пропсы — это способ передачи данных от родительского компонента к дочернему. Они передаются как атрибуты JSX. Дочерний компонент получает пропсы как аргумент своей функции.' },
    { title: 'Что такое состояние (state) в React? Чем оно отличается от пропсов?', content: 'Состояние — это данные, которые управляются самим компонентом и могут изменяться со временем. Пропсы передаются извне и являются read-only для дочернего компонента.' },
    { title: 'Что такое React Router? Для чего он нужен?', content: 'React Router — это библиотека для навигации в React-приложениях. Она позволяет создавать одностраничные приложения (SPA) с различными URL-адресами, отображающими разные компоненты без перезагрузки страницы.' },
    { title: ' Расскажите о Redux или другой библиотеке для управления состоянием (например, Context API, Zustand). Какие проблемы они решают?', content: ' Redux (или другая библиотека) используется для централизованного управления состоянием в больших React-приложениях. Это упрощает обмен данными между компонентами, делает состояние предсказуемым и облегчает отладку. Context API предоставляет способ передачи данных через дерево компонентов без необходимости передавать пропсы вручную на каждом уровне.' },
]

export const css = [
    { title: 'Что такое Flexbox и Grid? В каких случаях лучше использовать каждый из них?', content: 'Flexbox: Одномерная система раскладки, лучше подходит для распределения элементов вдоль одной оси (строки или столбца).Grid: Двумерная система раскладки, предназначена для более сложных макетов с рядами и столбцами.' },
    { title: 'Что такое CSS-препроцессоры (например, Sass, Less)? Какие преимущества они дают?', content: 'CSS-препроцессоры расширяют возможности CSS, добавляя такие функции, как переменные, вложенные правила, миксины и функции. Это упрощает написание и поддержку CSS, делая его более модульным и организованным.' },
    { title: 'Расскажите о методологии БЭМ (Блок, Элемент, Модификатор).', content: 'БЭМ — это методология именования CSS-классов, которая помогает создавать модульные, многократно используемые и легко поддерживаемые компоненты. Она основана на разделении интерфейса на независимые блоки, элементы внутри блоков и модификаторы, изменяющие внешний вид или поведение блоков/элементов.' },
    { title: '', content: '' },
    { title: '', content: '' },
    { title: '', content: '' },
]

export const git = [
    { title: 'Расскажите о вашем опыте работы с системами контроля версий (например, Git). Какие команды вы часто используете?', content: '(Опишите свой опыт работы с Git, упомяните часто используемые команды: git clone, git add, git commit, git push, git pull, git branch, git merge, git checkout).' },
    { title: 'Какие инструменты для отладки вы используете во фронтенд-разработке?', content: '(Например, DevTools браузера, React Developer Tools, Redux DevTools, console.log).' },
    { title: 'Как вы подходите к оптимизации производительности фронтенд-приложений?', content: '(Например, code splitting, lazy loading, оптимизация изображений, мемоизация компонентов, виртуализация списков).' },
    { title: 'Что вы знаете о принципах SOLID применительно к JavaScript/React?', content: 'Кратко опишите каждый принцип: единственной ответственности, открытости/закрытости, подстановки Лисков, разделения интерфейса, инверсии зависимостей и приведите примеры, как они могут применяться во фронтенде' },
    { title: '', content: '' },
    { title: '', content: '' },
]