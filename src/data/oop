ООП в JavaScript:

Вопрос: Как реализовать наследование в JavaScript до появления классов ES6?
Ответ: До ES6 наследование реализовывалось с помощью прототипного наследования. Обычно создавалась функция-конструктор, а затем прототипу этой функции присваивался экземпляр родительского "класса" (также функции-конструктора).

JavaScript
function Animal(name) {
  this.name = name;
}

Animal.prototype.speak = function() {
  console.log('Generic animal sound');
};

function Dog(name, breed) {
  Animal.call(this, name); // Вызов конструктора родителя
  this.breed = breed;
}

Dog.prototype = Object.create(Animal.prototype); // Установка прототипа
Dog.prototype.constructor = Dog; // Восстановление конструктора

Dog.prototype.bark = function() {
  console.log('Woof!');
};

const myDog = new Dog('Buddy', 'Golden Retriever');
myDog.speak(); // Выведет "Generic animal sound"
myDog.bark();  // Выведет "Woof!"
 Вопрос: Что такое классы в ES6 JavaScript? Являются ли они настоящими классами, как в других языках ООП?
Ответ: Классы в ES6 предоставляют более удобный синтаксис для создания объектов и работы с прототипным наследованием. Под капотом они все еще используют прототипное наследование, поэтому технически не являются "классами" в классическом понимании, как, например, в Java или C++. Однако они предоставляют более привычный синтаксис для разработчиков, знакомых с ООП.

JavaScript
class Animal {
  constructor(name) {
    this.name = name;
  }

  speak() {
    console.log('Generic animal sound');
  }
}

class Dog extends Animal {
  constructor(name, breed) {
    super(name); // Вызов конструктора родительского класса
    this.breed = breed;
  }

  bark() {
    console.log('Woof!');
  }
}

const myDog = new Dog('Buddy', 'Golden Retriever');
myDog.speak();
myDog.bark();
 Вопрос: Расскажите об основных принципах ООП (инкапсуляция, наследование, полиморфизм) и как они проявляются в JavaScript.
Ответ:

Инкапсуляция: Сокрытие внутреннего состояния объекта и предоставление контролируемого доступа к нему через методы. В JavaScript это достигается через области видимости (хотя приватные поля появились относительно недавно с #).
Наследование: Возможность создания новых классов на основе существующих, что позволяет повторно использовать код. В JavaScript реализуется через прототипное наследование или ключевое слово extends в классах ES6.
Полиморфизм: Возможность объектов разных классов реагировать на один и тот же метод по-разному. В JavaScript это достигается благодаря динамической типизации и тому, как вызываются методы объектов.